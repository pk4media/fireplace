{"name":"Fireplace","tagline":"Firebase addon for Ember.js","body":"# Fireplace\r\n\r\nFireplace is an [Ember.js](http://emberjs.com) adapter for [Firebase](http://firebase.com).\r\n\r\n## Getting Started\r\n\r\nSetup your Firebase root path:\r\n\r\n```javascript\r\nApp.Store = FP.Store.extend({\r\n  firebaseRoot: \"https://your-firebase.firebaseio.com\"\r\n});\r\n```\r\n\r\n## Models & Attributes\r\n\r\nDefine a model by extending from `FP.Model` and giving it some attributes:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  firstName: FP.attr(),\r\n  lastName: FP.attr()\r\n});\r\n```\r\n\r\nTyping `FP.attr()` all the time can get a bit repetitive, so you can assign that to a variable\r\nto reduce the amount of typing. All subsequent examples will assume this:\r\n\r\n```javascript\r\nvar attr = FP.attr;\r\nApp.Person = FP.Model.extend({\r\n  firstName: attr(),\r\n  lastName: attr()\r\n});\r\n```\r\n\r\n`FP.attr` takes a type which tells it how to transform to and from Firebase, and options.\r\n\r\nFireplace supports the following types out of the box:\r\n\r\n* `string` (the default if no type is supplied)\r\n* `boolean`\r\n* `date` (iso8601 formatted date)\r\n* `hash`\r\n* `number`\r\n* `timestamp` (the epoch returned from date.getTime())\r\n\r\n### Custom Keys\r\n\r\nYou can change the key used to serialize the data to/from Firebase with the `key` option.\r\nBy default this is the underscored version of the name, so `firstName` maps to `first_name`.\r\n\r\nFor example, lets add a date of birth date attribute and map the lastName attribute to \"surname\":\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  firstName: attr(),\r\n  lastName: attr({key: \"surname\"}),\r\n  dob: attr(\"date\")\r\n})\r\n```\r\n\r\n### Default Values\r\n\r\nAttributes can have default values, specify this with the `default` option which can be either\r\nthe value itself or a function which returns the default value (good for dates etc...)\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  firstName: attr({default: \"John\"}),\r\n  lastName: attr({default: \"Smith\"}),\r\n  createdAt: attr(\"date\", {default: function() { return new Date(); }})\r\n})\r\n```\r\n\r\n## Saving\r\n\r\nNow that we've defined a basic model, let's save it to Firebase.\r\n\r\nAs with Ember Data, the `Store` is our access point into Fireplace and it's injected into all controllers\r\nand routes.\r\n\r\nWe create an instance of a model with `store.createRecord` and then save it with `model.save()`:\r\n\r\n```javascript\r\nvar person = this.store.createRecord(\"person\", {\r\n  firstName: \"Bob\",\r\n  lastName: \"Johnson\"\r\n});\r\n\r\nperson.save();\r\n```\r\n\r\nNow the model is saved, it's now live and any changes which occur in Firebase are reflected in the local instance.\r\n\r\nSaving a model returns a promise, so we can wait for Firebase to confirm that the changes are saved like so:\r\n\r\n```javascript\r\nperson.save().then(function(){\r\n  // do something here, like transitioning to a route etc...\r\n});\r\n```\r\n\r\n`Model#save` is a shortcut to `Store#saveRecord` so if you prefer to type more then the above example could\r\nbe re-written as:\r\n\r\n```javascript\r\nvar person = this.store.createRecord(\"person\", {\r\n  firstName: \"Bob\",\r\n  lastName: \"Johnson\"\r\n});\r\n\r\nthis.store.saveRecord(person);\r\n```\r\n\r\n## Deleting\r\n\r\nSimply call `delete` on a model to delete it.\r\n\r\nAs with saving, we return a promise so you can wait for Firebase to confirm that the save succeeded.\r\n\r\nLikewise with saving, `Model#delete` is syntactic sugar for `Store#deleteRecord`.\r\n\r\n## Finding\r\n\r\nWe've now saved some data to Firebase, lets go get it back out again.\r\n\r\nAll examples below use `store.fetch` as that returns a promise which works with Ember's router.\r\nYou can use `store.find` instead to immediately return a model / collection.\r\n\r\n### Finding individual records\r\n\r\nLet's say we've got a person saved with an ID of \"123\", we can fetch that with:\r\n\r\n```javascript\r\nthis.store.fetch(\"person\", \"123\");\r\n```\r\n\r\nOnce resolved, the record will be live and update itself whenever Firebase updates.\r\n\r\nIf more data is required to build the Firebase reference (see customising references later) then\r\nwe can provide them as a 3rd argument:\r\n\r\nEg if a list of tasks is at `/projects/some-project/tasks/123` then we might do something like:\r\n\r\n```javascript\r\nthis.store.fetch(\"task\", \"123\", {project: someProject});\r\n```\r\n\r\n### Finding lists of records\r\n\r\nTo find every item in a list:\r\n\r\n```javascript\r\nthis.store.fetch(\"person\")\r\n```\r\n\r\nTo limit to a number of records, or provide a start/end point then we can supply an options object:\r\n\r\n```javascript\r\nthis.store.fetch(\"person\", {limit: 10, startAt: \"123\", endAt: \"456\"})\r\n```\r\n\r\nIf we need to provide more data to build the Firebase reference, then we provide them before the limit options:\r\n\r\n```javascript\r\nthis.store.fetch(\"task\", {project: someProject}, {limit: 10, startAt: \"123\", endAt: \"456\"})\r\n```\r\n\r\n## Relationships\r\n\r\n### hasOne\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  firstName: attr(),\r\n  lastName: attr()\r\n  address: FP.hasOne()\r\n});\r\n\r\nApp.Address = FP.Model.address({\r\n  street: attr(),\r\n  city: attr(),\r\n  postcode: attr()\r\n});\r\n```\r\n\r\nThis maps to the Firebase JSON of:\r\n\r\n```javascript\r\n{\r\n  first_name: \"John\",\r\n  last_name: \"Watson\",\r\n  address: {\r\n    street: \"221B Baker Street\",\r\n    city: \"London\",\r\n    postcode: \"NW1 6XE\"\r\n  }\r\n}\r\n```\r\n\r\nBy default `hasOne` guesses the name of the associated type based on the name of the property,\r\nin this case `address`.\r\n\r\nIf you want to call the property something different to the model type, pass its name as the first argument:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  residence: FP.hasOne(\"address\")\r\n});\r\n```\r\n\r\nFirebase stores data in a tree structure, so Fireplace by default treats all relationships\r\nas embedded. We can set the `embedded: false` option to change this:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  firstName: attr(),\r\n  lastName: attr(),\r\n  address: FP.hasOne({embedded: false})\r\n});\r\n```\r\n\r\nand now the JSON is:\r\n\r\n```javascript\r\n{\r\n  first_name: \"John\",\r\n  last_name: \"Watson\",\r\n  address: 123\r\n}\r\n```\r\n\r\nThis assumes that the address is stored at `/addresses/123` where `123` is the ID of the address.\r\n\r\nWe'll cover configuring the path of the item in Firebase later.\r\n\r\n\r\n### hasMany\r\n\r\nLets say our person lives in many different places, we can model this like so:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  firstName: attr(),\r\n  lastName: attr(),\r\n  addresses: FP.hasMany()\r\n});\r\n\r\nApp.Address = FP.Model.address({\r\n  street: attr(),\r\n  city: attr(),\r\n  postcode: attr()\r\n});\r\n```\r\n\r\nThe JSON for this is now:\r\n\r\n```javascript\r\n{\r\n  first_name: \"The\",\r\n  last_name: \"Queen\",\r\n  addresses: {\r\n    123: {\r\n      street: \"Buckingham Palace\",\r\n      city: \"London\",\r\n      postcode: \"SW1A 1AA\"\r\n    },\r\n    456: {\r\n      street: \"Windsor Castle\",\r\n      city: \"London\",\r\n      postcode: \"SL4 1NJ\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nLike hasOne, `hasMany` guesses the name of the associated type based on the singular name of the property,\r\nin this case `addresses` -> `address`.\r\n\r\nIf you want to call the property something different to the model type, pass its name as the first argument:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  residences: FP.hasOne(\"address\")\r\n});\r\n```\r\n\r\nAgain, we can change this to non-embedded by setting `{embedded: false}` to produce:\r\n\r\n```javascript\r\n{\r\n  first_name: \"The\",\r\n  last_name: \"Queen\",\r\n  addresses: {\r\n    123: true,\r\n    456: true\r\n  }\r\n}\r\n```\r\n\r\n#### Storing additional data with a non-embedded relationship\r\n\r\nBy default the relationships are stored as `{id: true}`, but we can store information there too.\r\n\r\nLets say we have projects which have people as members and each member has an access level.\r\n\r\nBecause it's a `hasMany` relationship, we can't store the meta information for the relationship\r\non the model itself because that person object can belong to many different projects.\r\n\r\nInstead we use a `MetaModel` which lets us store the information for this particular member.\r\n\r\n```javascript\r\nApp.Project = FP.Model.extend({\r\n  title: attr(),\r\n  members: FP.hasMany(\"people\", {embedded: false, as: \"member\"})\r\n});\r\n\r\nApp.Member = FP.MetaModel.extend();\r\n```\r\n\r\nThe JSON for this would now be something like:\r\n\r\n```javascript\r\n{\r\n  title: \"A project\",\r\n  members: {\r\n    123: \"admin\",\r\n    234: \"member\",\r\n    345: \"admin\"\r\n  }\r\n}\r\n```\r\n\r\nThe meta value is available on the meta model as `meta`:\r\n\r\n```javascript\r\nvar member = project.get(\"firstObject\");\r\nmember.get(\"meta\"); => \"admin\"\r\n```\r\n\r\nTo change this to something more descriptive, you can use `Ember.computed.alias`:\r\n\r\n```javascript\r\nApp.Member = FP.MetaModel.extend({\r\n  accessLevel: Ember.computed.alias(\"meta\")\r\n});\r\n```\r\n\r\nIf you want to store more complex data on a relationship, you can give the `MetaModel` attributes\r\nand relationships just like a normal model. All the same rules apply:\r\n\r\n```javascript\r\nApp.Member = FP.MetaModel.extend({\r\n  accessLevel: attr(),\r\n  joinedAt: attr(\"date\")\r\n});\r\n```\r\n\r\nThis would produce JSON like so:\r\n\r\n```javascript\r\n{\r\n  title: \"A project\",\r\n  members: {\r\n    123: {\r\n      access_level: \"admin\",\r\n      joined_at: \"2012-11-24T15:00:00\"\r\n    },\r\n    234: {\r\n      access_level: \"member\",\r\n      joined_at: \"2012-12-11T14:30:00\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nKeep in mind that, when using `MetaModel`s, you have to set the actual model as the `content` property on the `MetaModel` and then add the `MetaModel` to the parent's collection like in this sample:\r\n\r\n```javascript\r\n// project and person (of class People) are loaded already\r\nvar member = store.createRecord('member', {\r\n  accessLevel: \"admin\",\r\n  joinedAt: new Date(),\r\n  content: person // the actual \"content\" of this relationship\r\n});\r\n\r\nproject.get('members').addObject(member);\r\nproject.save();\r\n```\r\n\r\nWhen loading projects and getting members, the `MetaModel`'s properties are available on the *real* member (instance of `People`) as if they were a part of it. \r\n\r\n### Detached relationships\r\n\r\nAll the above examples assume that the associated object itself or its ID is stored with the parent,\r\nbut what if you want to store something completely separately? Here we can use detached relationships.\r\n\r\nFor example, lets say we stored people with their avatars completely separately in the tree because\r\nwe're storing the image data and we don't want to include that by default when we fetch a list of people.\r\nWe don't store the avatar ID with the person because maybe every person has an avatar, so the JSON's something like:\r\n\r\n```javascript\r\n{\r\n  people: {\r\n    123: {\r\n      name: \"John Smith\"\r\n    }\r\n  },\r\n  avatars: {\r\n    123: {\r\n      filename: \"an-image.png\",\r\n      data: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nWe can model this like so:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  name: attr(),\r\n  avatar: FP.hasOne({detached: true})\r\n});\r\n```\r\n\r\nBy default this then looks for the avatar at `/avatars/{{id}}`, we'll look at how to change that later\r\nshould you want to store things in a different place.\r\n\r\nDetached hasMany relationships are specified in a similar way, say a task can be assigned to multiple\r\npeople, but we want to be able to list them for a specific person. We could set this up in Firebase like so:\r\n\r\n```javascript\r\n{\r\n  people: {\r\n    123: {\r\n      name: \"Tom Ford\"\r\n    },\r\n    234: {\r\n      name: \"Paul Smith\"\r\n    },\r\n  },\r\n  tasks_by_person: {\r\n    123: {\r\n      345: true,\r\n      456: true\r\n    },\r\n    234: {\r\n      345: true\r\n    }\r\n  },\r\n  tasks: {\r\n    345: {\r\n      title: \"A task assigned to both people\",\r\n      assignees: {\r\n        123: true,\r\n        234: true\r\n      }\r\n    },\r\n    456: {\r\n      title: \"A task assigned to one person\",\r\n      assignees: {\r\n        123: true\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nHere we've got a list of people, a list of tasks and an index which maps each person to their tasks.\r\n\r\nWe can model this like so:\r\n\r\n```javascript\r\nApp.Task = FP.Model.extend({\r\n  title: attr(),\r\n  assignees: FP.hasMany(\"people\")\r\n});\r\n\r\nApp.Person = FP.Model.extend({\r\n  name: attr(),\r\n  tasks: FP.hasMany({detached: true, path: \"tasks_by_person/{{id}}\"})\r\n});\r\n```\r\n\r\nIf the given `path` is a string, as it is here, it's expanded and appended to the root Firebase path.\r\n\r\nFor complete control over the path you can provide a function and return either a string or a Firebase\r\nreference:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  tasks: FP.hasMany({\r\n    detached: true,\r\n    path: function() {\r\n      return this.get(\"project\").buildFirebaseReference().\r\n        child(\"tasks/by-person\").\r\n        child(this.get(\"id\"));\r\n    }\r\n  })\r\n});\r\n```\r\n\r\nA detached hasMany is assumed to be an indexed collection, as opposed to a collection of the items itself.\r\n\r\n## Priorities\r\n\r\nIf a model has a `priority` property, then that's used when saving to Firebase.\r\n\r\nFor example, lets say we want to order all people by their full name, last name first:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  firstName: attr(),\r\n  lastName: attr(),\r\n  priority: function(){\r\n    return [this.get(\"firstName\"), this.get(\"lastName\")].join(\" \").toLowerCase();\r\n  }.property(\"firstName\", \"lastName\")\r\n})\r\n```\r\n\r\nNote that the priority here is a normal Ember property and not an `FP.attr`. That's because we're not\r\nstoring it as an attribute in the JSON.\r\n\r\nThe same applies to a `MetaModel` so you can order items in an indexed list.\r\n\r\nFor example, lets order a list of members by the date they were added to a project:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  firstName: attr(),\r\n  lastName: attr()\r\n})\r\n\r\nApp.Project = FP.Model.extend({\r\n  title: attr(),\r\n  members: hasMany(\"people\", {as: \"member\"})\r\n})\r\n\r\nApp.Member = FP.MetaModel.extend({\r\n  createdAt: attr(\"date\"),\r\n\r\n  priority: function(){\r\n    return this.get(\"createdAt\").toISOString();\r\n  }.property(\"createdAt\")\r\n})\r\n```\r\n\r\n## Customising where data is stored\r\n\r\nBy default Fireplace assumes that non-embedded records will be stored at the root of your store's Firebase reference\r\nwith each model type stored under its pluralized underscored name.\r\n\r\nEmbedded records are stored relative to their parent records.\r\n\r\nFor example, each `App.Person` is stored at `/people/id`.\r\n\r\nTo customise this you can override the `firebasePath` property on the model's class.\r\n\r\nLet's change `App.Person` to store its data at `/member/profiles` instead of `/people`:\r\n\r\n```javascript\r\nApp.Person.reopenClass({\r\n  firebasePath: \"member/profiles\"\r\n});\r\n```\r\n\r\nAny handlebars style parameters will be expanded, so lets say we store each person under the project\r\nthey are a member of, eg `/projects/123/people/456`, then we can provide a path like so:\r\n\r\n```javascript\r\nApp.Person.reopenClass({\r\n  firebasePath: \"projects/{{project.id}}/people\"\r\n});\r\n```\r\n\r\nIn this case, whenever we look for a person we'll need to provide the project and the model should have\r\na project property so that it knows where it is to be saved to.\r\n\r\n```javascript\r\nthis.store.fetch(\"person\", {project: someProject});\r\n```\r\n\r\nFinally, for complete control you can specify a function, the equivalent to the template string above would be:\r\n\r\n```javascript\r\nApp.Person.reopenClass({\r\n  firebasePath: function(options) {\r\n    var projectID = options.get(\"project.id\");\r\n    return \"projects/\"+projectID+\"/people\";\r\n  }\r\n})\r\n```\r\n\r\n## Custom collections\r\n\r\nThere are two types of collection built in:\r\n\r\n* `FP.ObjectCollection` - returned from finders and hasMany embedded relationships\r\n* `FP.IndexedCollection` - returned from hasMany non-embedded / detached relationships\r\n\r\nYou can create a custom collection by extending either of these as a starting point.\r\n\r\nFor example, lets make a collection of objects which sets a random priority when items are added:\r\n\r\n```javascript\r\nApp.RandomCollection = FP.ObjectCollection.extend({\r\n\r\n  replaceContent: function(idx, numRemoved, objectsAdded) {\r\n    var priority;\r\n    objectsAdded.forEach(function(obj, i) {\r\n      if (!obj.get(\"priority\")) {\r\n        priority = Math.random();\r\n        obj.set(\"priority\", priority);\r\n      }\r\n    });\r\n    return this._super(idx, numRemoved, objectsAdded);\r\n  }\r\n\r\n});\r\n```\r\n\r\nWe can now use this in queries:\r\n\r\n```javascript\r\nthis.store.fetch(\"person\", {collection: \"random\"})\r\n```\r\n\r\nand in relationships:\r\n\r\n```javascript\r\nApp.Person = FP.Model.extend({\r\n  tasks: hasMany({collection: \"random\"})\r\n});\r\n```\r\n\r\n## Forking the Store\r\n\r\nYou can fork the store to make changes which don't affect any existing data until you save.\r\n\r\nFor example, if you have an editing interface and you don't want changes to affect parts of the\r\npage which are being displayed with that record's details then you can fork the store and\r\nget a new copy of the record which is totally isolated:\r\n\r\n```javascript\r\nvar person = this.store.find(\"person\", 1);\r\nvar newStore = this.store.fork();\r\nvar personClone = newStore.find(\"person\", 1);\r\n```\r\n\r\nWhen you save `personClone` then `person` will also update, but not until then.\r\n\r\nWe fork the store instead of just copying the record because this makes sure we have a completely fresh\r\ncache & that all embedded records are also isolated.\r\n\r\n## Ember Inspector\r\n\r\nFireplace supports the [Chrome Ember Inspector](https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi?hl=en)\r\n\r\n## Building Fireplace\r\n\r\nFireplace uses [node.js](http://nodejs.org/) and [grunt](http://gruntjs.com/) as a build system,\r\nThese two libraries will need to be installed before building.\r\n\r\nTo build Fireplace, clone the repository, and run `npm install` to install build dependencies\r\nand `grunt` to build the library.\r\n\r\nUnminified and minified builds of Fireplace will be placed in the `dist`\r\ndirectory.\r\n\r\n## How to Run Unit Tests\r\n\r\n### Setup\r\n\r\nFireplace uses [node.js](http://nodejs.org/) and [grunt](http://gruntjs.com/) as a build system\r\nand test runner, and [bower](http://bower.io/) for dependency management.\r\n\r\nIf you have not used any of these tools before, you will need to run `npm install -g bower` and\r\n`npm install -g grunt-cli` to be able to use them.\r\n\r\nTo test Fireplace run `npm install` to install build dependencies, `bower install` to install the\r\nruntime dependencies and `grunt test` to execute the test suite headlessly via phantomjs.\r\n\r\nIf you prefer to run tests in a browser, you may start a development server using\r\n`grunt develop`. Tests are available at http://localhost:8000/tests\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}